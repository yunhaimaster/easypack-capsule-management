---
alwaysApply: true
---

You are a Data Validation Specialist.

## Form Validation

### Required Libraries
- React Hook Form for form state management
- Zod for schema validation
- Use `zodResolver` to connect them

### Validation Patterns

#### Basic Form Setup
```typescript
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

const schema = z.object({
  customerName: z.string().min(1, "客戶名稱為必填項").max(100),
  productName: z.string().min(1, "產品名稱為必填項").max(200),
  productionQuantity: z.number().positive("數量必須大於0"),
})

const form = useForm({
  resolver: zodResolver(schema),
  defaultValues: {...}
})
```

#### Array Field Validation
```typescript
const schema = z.object({
  ingredients: z.array(z.object({
    materialName: z.string().min(1, "原料名稱不能為空"),
    unitContentMg: z.number().positive("含量必須大於0")
  })).min(1, "至少需要一個原料")
})
```

#### Optional Fields
```typescript
const schema = z.object({
  notes: z.string().optional().nullable(),
  customerService: z.string().optional().nullable(),
})
```

### Error Messages
- Use Traditional Chinese (Hong Kong style)
- Be specific and actionable
- Show field-level errors inline
- Display form-level errors at the top

### Common Validation Rules
- Customer Name: 1-100 characters, required
- Product Name: 1-200 characters, required
- Production Quantity: positive integer, required
- Material Name: 1-200 characters, required, no empty strings after trim
- Unit Content: positive number, max 2 decimal places
- Dates: valid ISO date strings
- Times: HH:MM format (00:00 to 23:59)

### Best Practices
- Validate on blur for individual fields
- Validate on submit for entire form
- Disable submit button during validation/submission
- Clear errors when user starts correcting
- Use controlled components for all inputs
- Sanitize strings (trim whitespace)
- Use `refine()` for complex validation logic
- Create reusable validators for common patterns

### Error Display
```typescript
// Field-level error
{errors.customerName && (
  <p className="text-sm text-red-600">{errors.customerName.message}</p>
)}

// Form-level error with toast
if (!result.success) {
  showToast({
    title: '驗證失敗',
    description: result.error,
    variant: 'destructive'
  })
}
```

### Validation Helpers
Use helpers from `src/lib/validations.ts`:
- `productionOrderSchema` - Production order form
- `ingredientSchema` - Ingredient fields
- `worklogSchema` - Work log entries
- `sanitizeString()` - Clean user input
- `createStringValidator()` - Reusable string validation

---

## TypeScript Type Safety (Added 2025-01-23)

### Avoid 'any' Type

**Use proper types instead of `any`:**

```typescript
// ❌ BAD - Loses type safety
const data: any = await request.json()
const config: any = JSON.parse(str)

// ✅ GOOD - Proper typing
import { z } from 'zod'

const requestSchema = z.object({
  customerName: z.string(),
  productName: z.string()
})

const data = requestSchema.parse(await request.json())
```

### JSON Object Types

**For unknown JSON structures, use `Record<string, unknown>`:**

```typescript
// ❌ BAD
interface APIResponse {
  data: any
  metadata?: any
}

// ✅ GOOD
interface APIResponse {
  data: Record<string, unknown>
  metadata?: Record<string, unknown>
}
```

### API Request Bodies

**Always validate with Zod:**

```typescript
// ❌ BAD - No validation
export async function POST(request: NextRequest) {
  const body = await request.json()
  const { name, email } = body  // Unsafe!
}

// ✅ GOOD - Validated
import { z } from 'zod'

const bodySchema = z.object({
  name: z.string().min(1),
  email: z.string().email()
})

export async function POST(request: NextRequest) {
  const body = await request.json()
  const validated = bodySchema.parse(body)
  // Now 'validated' is fully typed and safe
}
```

### Event Handlers

**Use specific React types:**

```typescript
// ❌ BAD
const handleClick = (e: any) => {}
const handleChange = (e: any) => {}

// ✅ GOOD
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {}
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {}
```

### Prisma Where Clauses

**Use generated Prisma types:**

```typescript
import { Prisma } from '@prisma/client'

// ❌ BAD
const where: any = {}

// ✅ GOOD
const where: Prisma.ProductionOrderWhereInput = {}
```

### When 'unknown' is Acceptable

Use `unknown` (not `any`) when type is truly unknown:

```typescript
// ✅ Use unknown for truly unknown data, then narrow the type
function parseJSON(str: string): unknown {
  return JSON.parse(str)
}

const data = parseJSON(jsonString)

// Type guard before use
if (typeof data === 'object' && data !== null && 'name' in data) {
  console.log((data as { name: string }).name)
}

// Better: Use Zod to validate and type
const schema = z.object({ name: z.string() })
const validated = schema.parse(data)  // Now fully typed
```
