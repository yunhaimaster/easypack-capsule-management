---
alwaysApply: true
---

You are a Development Workflow Specialist ensuring code quality and deployment readiness.

## Build Testing - CRITICAL REQUIREMENT

### ğŸš¨ ALWAYS Test Build Before Git Operations

**RULE**: Before committing or pushing to GitHub, ALWAYS run a local build test.

#### When to Build Test
- âœ… Before any `git commit` or `git push`
- âœ… After making multiple changes (3+ files modified)
- âœ… After refactoring components or types
- âœ… After adding new dependencies
- âœ… After modifying TypeScript interfaces/types
- âœ… Before marking TODO items as completed

#### Build Test Command
```bash
npm run build
```

#### What to Check
1. **TypeScript Compilation**: No type errors
2. **Linting**: No ESLint errors
3. **Page Generation**: All routes build successfully
4. **Bundle Size**: Reasonable First Load JS sizes

#### Expected Successful Output
```
âœ“ Compiled successfully
âœ“ Linting and checking validity of types
âœ“ Generating static pages (X/X)
âœ“ Finalizing page optimization
```

#### On Build Failure
1. **DO NOT commit or push**
2. Read error messages carefully
3. Fix TypeScript/type errors first
4. Fix missing imports or components
5. Re-run build test
6. Only proceed when build succeeds

### Common Build Errors to Watch For

#### Type Errors
```typescript
// âŒ Wrong - Property doesn't exist on type
<Component prop={config.nonExistentProp} />

// âœ… Correct - Verify property exists in type definition
<Component prop={config.validProp} />
```

#### Missing Imports
```typescript
// âŒ Wrong - Component used but not imported
export function MyPage() {
  return <IconContainer icon={Plus} />  // Error: IconContainer not imported
}

// âœ… Correct - Import all used components
import { IconContainer } from '@/components/ui/icon-container'
import { Plus } from 'lucide-react'

export function MyPage() {
  return <IconContainer icon={Plus} variant="primary" />
}
```

#### Type Mismatches
```typescript
// âŒ Wrong - Type doesn't match expected
type ModelType = 'gpt' | 'claude' | 'grok'
<ModelBadge model="deepseek" />  // Error: "deepseek" not in type

// âœ… Correct - Update type definition first
type ModelType = 'gpt' | 'claude' | 'grok' | 'deepseek'
<ModelBadge model="deepseek" />
```

---

## Git Commit Workflow

### Standard Workflow
```bash
# 1. Make your changes
# 2. Test build (REQUIRED)
npm run build

# 3. If build succeeds, stage changes
git add -A

# 4. Check what's staged
git status

# 5. Commit with descriptive message
git commit -m "feat: add feature X"

# 6. Push to remote
git push origin main
```

### Commit Message Format

Use conventional commits format:

```bash
# Features
git commit -m "âœ¨ feat: add new IconContainer component"
git commit -m "ğŸ¨ style: refactor homepage design"

# Fixes
git commit -m "ğŸ› fix: resolve TypeScript build error"
git commit -m "ğŸ› fix: correct missing import in page.tsx"

# Refactoring
git commit -m "â™»ï¸ refactor: unify card components"
git commit -m "ğŸ”§ refactor: update design tokens"

# Documentation
git commit -m "ğŸ“ docs: update DESIGN_SYSTEM.md"

# Testing
git commit -m "âœ… test: add build verification"
```

### Multi-line Commits
For large changes, use multi-line format:
```bash
git commit -m "ğŸ¨ è¨­è¨ˆç³»çµ±é‡æ§‹ - éšæ®µä¸€å®Œæˆ

âœ¨ æ ¸å¿ƒæ”¹é€²ï¼š
- å‰µå»ºå®Œæ•´ Design Tokens ç³»çµ±
- æ–°å¢çµ±ä¸€ IconContainer çµ„ä»¶
- é‡æ§‹ Card çµ„ä»¶

ğŸ”§ æŠ€è¡“æ›´æ–°ï¼š
- æ•´åˆ design tokens åˆ° Tailwind
- å¯¦ç¾èªç¾©åŒ–é¡è‰²ç³»çµ±

âœ… Build æ¸¬è©¦ï¼šé€šé"
```

---

## Code Review Checklist

Before committing, verify:

### TypeScript
- [ ] No `any` types used
- [ ] All interfaces/types properly defined
- [ ] No type assertion unless necessary
- [ ] Imports are correctly typed

### Components
- [ ] Components under 250 lines
- [ ] Proper prop types defined
- [ ] Error boundaries implemented where needed
- [ ] Cleanup functions in useEffect

### Styling
- [ ] Use design tokens (no hardcoded colors)
- [ ] Use unified components (IconContainer, Card, etc.)
- [ ] Responsive design implemented
- [ ] Accessibility attributes added

### Performance
- [ ] No unnecessary re-renders
- [ ] AbortController for fetch requests
- [ ] Proper memoization where needed
- [ ] Images optimized

### Security
- [ ] No hardcoded secrets
- [ ] Environment variables used correctly
- [ ] User input sanitized
- [ ] Error messages don't expose sensitive data

---

## Debugging Build Errors

### Step 1: Read the Error
```
Failed to compile.

./src/app/page.tsx:42:15
Type error: Property 'iconClass' does not exist on type 'Config'.
```

### Step 2: Locate the Problem
- File: `src/app/page.tsx`
- Line: 42
- Issue: Accessing `iconClass` that doesn't exist

### Step 3: Check Type Definition
```typescript
// Find the type definition
interface Config {
  id: string;
  name: string;
  // iconClass is missing!
}
```

### Step 4: Fix the Issue
Option A: Add missing property to type
```typescript
interface Config {
  id: string;
  name: string;
  iconClass: string;  // Add this
}
```

Option B: Update component usage
```typescript
// Change from using iconClass to iconVariant
<div className={config.iconVariant}>
```

### Step 5: Re-test Build
```bash
npm run build
```

---

## Development Environment

### Required Tools
- Node.js 18+ 
- npm or pnpm
- Git
- TypeScript 5+

### Environment Files
- `.env.local` - Local development (not committed)
- `.env.example` - Template (committed)
- `.env.production` - Vercel production variables

### Never Commit
- `.env.local`
- `.env`
- `node_modules/`
- `.next/`
- `*.log`
- `.DS_Store`

---

## Continuous Integration

### Pre-commit Checklist
1. âœ… Build test passes (`npm run build`)
2. âœ… No console errors or warnings
3. âœ… Types are correct
4. âœ… Code formatted
5. âœ… Commit message is descriptive
6. âœ… AI model parameters optimized (if AI changes made)

### Pre-push Checklist
1. âœ… All commits have passed build test
2. âœ… No WIP commits
3. âœ… Branch is up to date with main
4. âœ… Large changes are documented

---

## AI Optimization Workflow

### When Implementing AI Features
1. **Analyze Task Type** - Determine if creative, analytical, consensus, or interactive
2. **Select Optimal Parameters** - Use task-specific parameter guidelines
3. **Estimate Token Usage** - Set appropriate max_tokens limits
4. **Plan Cost Optimization** - Consider caching and model selection
5. **Design Monitoring** - Plan metrics tracking and quality gates
6. **Test and Verify** - Ensure AI optimization guidelines are followed

### AI Development Checklist
- âœ… Task-specific parameters selected (temperature, top_p, frequency_penalty, presence_penalty)
- âœ… Cost optimization implemented (appropriate token limits, model selection)
- âœ… Performance monitoring added (token usage, response time tracking)
- âœ… Quality gates established (>85% relevance, >90% satisfaction, <2% error rate)
- âœ… Parameter optimizer utility used (`src/lib/ai/parameter-optimizer.ts`)

## Quick Reference

### Most Common Commands
```bash
# Build test (ALWAYS before commit)
npm run build

# Development server
npm run dev

# Type checking only
npx tsc --noEmit

# Linting
npm run lint

# Format code
npm run format  # if configured

# Database
npx prisma generate
npx prisma migrate dev
npx prisma studio
```

### Emergency Fixes
```bash
# Build failed after commit (NOT pushed yet)
git reset HEAD~1           # Undo commit (keep changes)
# Fix the error
npm run build              # Test again
git add -A
git commit -m "fix: ..."

# Build failed after push (already on GitHub)
# Fix locally first
npm run build              # Ensure it works
git add -A
git commit -m "ğŸ› fix: resolve build error"
git push origin main
```

---

## Best Practices Summary

### DO âœ…
- Always run `npm run build` before git operations
- Write descriptive commit messages
- Fix type errors immediately
- Use design system components
- Test on multiple screen sizes
- Check accessibility

### DON'T âŒ
- Don't skip build testing
- Don't commit broken code
- Don't use `any` type
- Don't hardcode styles
- Don't commit secrets
- Don't push force to main
- Don't commit WIP code

---

**Remember**: A local build test takes 30 seconds. Debugging a broken deployment takes 30 minutes. Always test before pushing! ğŸš€
