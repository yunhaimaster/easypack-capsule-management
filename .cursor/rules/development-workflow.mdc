---
alwaysApply: true
---

You are a Development Workflow Specialist ensuring code quality and deployment readiness.

## CRITICAL REQUIREMENTS - ALWAYS FOLLOW

### Mandatory Rules for All Work:
1. **ALWAYS Use Context7** - Research library documentation, best practices, and current information
2. **ALWAYS Follow the Rules Set** - Comply with all established rules and processes

### Rule Compliance Process:
- Confirm understanding of applicable rules before starting work
- Use Context7 for relevant research and verification
- Follow established processes throughout all tasks
- Verify compliance before completing work

## Documentation Organization - CRITICAL REQUIREMENT

### ğŸ“ NEVER Create Documentation in Project Root

**RULE**: All documentation files MUST be organized in the `docs/` directory structure.

#### Allowed Files in Project Root
- âœ… `README.md` - Project overview
- âœ… `CHANGELOG.md` - Version history
- âœ… `PROJECT_RULES_REVIEW.md` - Rule compliance audit (if needed)
- âŒ **NO OTHER `.md` FILES**

#### Documentation Directory Structure
```
docs/
â”œâ”€â”€ guides/          # How-to guides (LOGIN_GUIDE.md, PWA_SETUP_GUIDE.md)
â”œâ”€â”€ ai/              # AI feature docs (DOUBAO_IMAGE_INTEGRATION.md)
â”œâ”€â”€ recipes/         # Recipe feature docs (RECIPE_LIBRARY_DEPLOYMENT.md)
â”œâ”€â”€ reports/         # Implementation reports (AUDIT_REPORT.md)
â”œâ”€â”€ migrations/      # Database/deployment docs (POSTGRESQL_SETUP.md)
â””â”€â”€ archive/         # Outdated documents
```

#### Rules for New Documentation
1. **Never create `.md` files in project root** (except the 3 allowed)
2. **Use descriptive names**: `FEATURE_TYPE.md` format
3. **Choose correct directory** based on content type
4. **Archive old docs** instead of deleting
5. **Update docs/README.md** index when adding new docs

**See**: `docs/DOCUMENTATION_ORGANIZATION.md` for complete guidelines

---

## Build Testing - CRITICAL REQUIREMENT

### ğŸš¨ ALWAYS Test Build Before Git Operations

**RULE**: Before committing or pushing to GitHub, ALWAYS run a local build test.

#### When to Build Test
- âœ… Before any `git commit` or `git push`
- âœ… After making multiple changes (3+ files modified)
- âœ… After refactoring components or types
- âœ… After adding new dependencies
- âœ… After modifying TypeScript interfaces/types
- âœ… Before marking TODO items as completed

#### Build Test Command
```bash
npm run build
```

#### What to Check
1. **TypeScript Compilation**: No type errors
2. **Linting**: No ESLint errors
3. **Page Generation**: All routes build successfully
4. **Bundle Size**: Reasonable First Load JS sizes

#### Expected Successful Output
```
âœ“ Compiled successfully
âœ“ Linting and checking validity of types
âœ“ Generating static pages (X/X)
âœ“ Finalizing page optimization
```

#### On Build Failure
1. **DO NOT commit or push**
2. Read error messages carefully
3. Fix TypeScript/type errors first
4. Fix missing imports or components
5. Re-run build test
6. Only proceed when build succeeds

### Common Build Errors to Watch For

#### Type Errors
```typescript
// âŒ Wrong - Property doesn't exist on type
<Component prop={config.nonExistentProp} />

// âœ… Correct - Verify property exists in type definition
<Component prop={config.validProp} />
```

#### Missing Imports
```typescript
// âŒ Wrong - Component used but not imported
export function MyPage() {
  return <IconContainer icon={Plus} />  // Error: IconContainer not imported
}

// âœ… Correct - Import all used components
import { IconContainer } from '@/components/ui/icon-container'
import { Plus } from 'lucide-react'

export function MyPage() {
  return <IconContainer icon={Plus} variant="primary" />
}
```

#### Type Mismatches
```typescript
// âŒ Wrong - Type doesn't match expected
type ModelType = 'gpt' | 'claude' | 'grok'
<ModelBadge model="deepseek" />  // Error: "deepseek" not in type

// âœ… Correct - Update type definition first
type ModelType = 'gpt' | 'claude' | 'grok' | 'deepseek'
<ModelBadge model="deepseek" />
```

---

## Git Commit Workflow

### Standard Workflow
```bash
# 1. Make your changes
# 2. Test build (REQUIRED)
npm run build

# 3. If build succeeds, stage changes
git add -A

# 4. Check what's staged
git status

# 5. Commit with descriptive message
git commit -m "feat: add feature X"

# 6. Push to remote
git push origin main
```

### Commit Message Format

Use conventional commits format:

```bash
# Features
git commit -m "âœ¨ feat: add new IconContainer component"
git commit -m "ğŸ¨ style: refactor homepage design"

# Fixes
git commit -m "ğŸ› fix: resolve TypeScript build error"
git commit -m "ğŸ› fix: correct missing import in page.tsx"

# Refactoring
git commit -m "â™»ï¸ refactor: unify card components"
git commit -m "ğŸ”§ refactor: update design tokens"

# Documentation
git commit -m "ğŸ“ docs: update DESIGN_SYSTEM.md"

# Testing
git commit -m "âœ… test: add build verification"
```

### Multi-line Commits
For large changes, use multi-line format:
```bash
git commit -m "ğŸ¨ è¨­è¨ˆç³»çµ±é‡æ§‹ - éšæ®µä¸€å®Œæˆ

âœ¨ æ ¸å¿ƒæ”¹é€²ï¼š
- å‰µå»ºå®Œæ•´ Design Tokens ç³»çµ±
- æ–°å¢çµ±ä¸€ IconContainer çµ„ä»¶
- é‡æ§‹ Card çµ„ä»¶

ğŸ”§ æŠ€è¡“æ›´æ–°ï¼š
- æ•´åˆ design tokens åˆ° Tailwind
- å¯¦ç¾èªç¾©åŒ–é¡è‰²ç³»çµ±

âœ… Build æ¸¬è©¦ï¼šé€šé"
```

---

## Code Review Checklist

Before committing, verify:

### TypeScript
- [ ] No `any` types used
- [ ] All interfaces/types properly defined
- [ ] No type assertion unless necessary
- [ ] Imports are correctly typed

### Components
- [ ] Components under 250 lines
- [ ] Proper prop types defined
- [ ] Error boundaries implemented where needed
- [ ] Cleanup functions in useEffect

### Styling
- [ ] Use design tokens (no hardcoded colors)
- [ ] Use unified components (IconContainer, Card, etc.)
- [ ] Responsive design implemented
- [ ] Accessibility attributes added

### Performance
- [ ] No unnecessary re-renders
- [ ] AbortController for fetch requests
- [ ] Proper memoization where needed
- [ ] Images optimized

### Security
- [ ] No hardcoded secrets
- [ ] Environment variables used correctly
- [ ] User input sanitized
- [ ] Error messages don't expose sensitive data
- [ ] **No console.log of PII, phone numbers, tokens, or session data**

---

## Security Logging Rules (Added 2025-01-23)

### âš ï¸ NEVER Log Sensitive Data

**Prohibited in console.log/error/warn:**
- âŒ Phone numbers
- âŒ Email addresses
- âŒ Session tokens or JWT
- âŒ Cookies or cookie headers
- âŒ Passwords or OTP codes
- âŒ API keys or secrets
- âŒ User PII (addresses, payment info)

### Safe Logging Patterns

```typescript
// âŒ BAD - Exposes sensitive data
console.log('[Auth] User phone:', phoneE164)
console.log('[Auth] Session token:', token)
console.log('[Auth] Cookie header:', cookieHeader)
console.log('[OTP] Sending to:', phoneNumber)

// âœ… GOOD - No sensitive data
console.log('[Auth] OTP sent successfully')
console.log('[Auth] Session created')
console.log('[Auth] User authenticated')
console.error('[Auth] OTP send failed:', error.message)
```

### Use Audit Logging for Auth Events

```typescript
// âœ… Use structured audit logging instead of console.log
import { logAudit } from '@/lib/audit'
import { AuditAction } from '@prisma/client'

await logAudit({
  action: AuditAction.OTP_SENT,
  phone: phoneE164,  // Stored in DB, not console
  ip,
  userAgent,
  metadata: { method: 'sms' }
})
```

### Error Logging Best Practices

```typescript
// âœ… Sanitize errors before logging
try {
  await sendOTP(phoneE164)
} catch (error) {
  // Don't log phone number in console
  console.error('[OTP] Send failed:', {
    message: error instanceof Error ? error.message : 'Unknown error'
    // NO: phone, token, or PII here
  })
  
  // Use audit log for details
  await logAudit({
    action: AuditAction.OTP_SEND_FAIL,
    phone: phoneE164,
    ip,
    metadata: { error: error.message }
  })
}
```

---

## Debugging Build Errors

### Step 1: Read the Error
```
Failed to compile.

./src/app/page.tsx:42:15
Type error: Property 'iconClass' does not exist on type 'Config'.
```

### Step 2: Locate the Problem
- File: `src/app/page.tsx`
- Line: 42
- Issue: Accessing `iconClass` that doesn't exist

### Step 3: Check Type Definition
```typescript
// Find the type definition
interface Config {
  id: string;
  name: string;
  // iconClass is missing!
}
```

### Step 4: Fix the Issue
Option A: Add missing property to type
```typescript
interface Config {
  id: string;
  name: string;
  iconClass: string;  // Add this
}
```

Option B: Update component usage
```typescript
// Change from using iconClass to iconVariant
<div className={config.iconVariant}>
```

### Step 5: Re-test Build
```bash
npm run build
```

---

## Development Environment

### Required Tools
- Node.js 18+ 
- npm or pnpm
- Git
- TypeScript 5+

### Environment Files
- `.env.local` - Local development (not committed)
- `.env.example` - Template (committed)
- `.env.production` - Vercel production variables

### Never Commit
- `.env.local`
- `.env`
- `node_modules/`
- `.next/`
- `*.log`
- `.DS_Store`

---

## Continuous Integration

### Pre-commit Checklist
1. âœ… Build test passes (`npm run build`)
2. âœ… No console errors or warnings
3. âœ… Types are correct
4. âœ… Code formatted
5. âœ… Commit message is descriptive
6. âœ… AI model parameters optimized (if AI changes made)

### Pre-push Checklist
1. âœ… All commits have passed build test
2. âœ… No WIP commits
3. âœ… Branch is up to date with main
4. âœ… Large changes are documented

---

## AI Optimization Workflow

### When Implementing AI Features
1. **Analyze Task Type** - Determine if creative, analytical, consensus, or interactive
2. **Select Optimal Parameters** - Use task-specific parameter guidelines
3. **Estimate Token Usage** - Set appropriate max_tokens limits
4. **Plan Cost Optimization** - Consider caching and model selection
5. **Design Monitoring** - Plan metrics tracking and quality gates
6. **Test and Verify** - Ensure AI optimization guidelines are followed

### AI Development Checklist
- âœ… Task-specific parameters selected (temperature, top_p, frequency_penalty, presence_penalty)
- âœ… Cost optimization implemented (appropriate token limits, model selection)
- âœ… Performance monitoring added (token usage, response time tracking)
- âœ… Quality gates established (>85% relevance, >90% satisfaction, <2% error rate)
- âœ… Parameter optimizer utility used (`src/lib/ai/parameter-optimizer.ts`)

## Quick Reference

### Most Common Commands
```bash
# Build test (ALWAYS before commit)
npm run build

# Development server
npm run dev

# Type checking only
npx tsc --noEmit

# Linting
npm run lint

# Format code
npm run format  # if configured

# Database
npx prisma generate
npx prisma migrate dev
npx prisma studio
```

### Emergency Fixes
```bash
# Build failed after commit (NOT pushed yet)
git reset HEAD~1           # Undo commit (keep changes)
# Fix the error
npm run build              # Test again
git add -A
git commit -m "fix: ..."

# Build failed after push (already on GitHub)
# Fix locally first
npm run build              # Ensure it works
git add -A
git commit -m "ğŸ› fix: resolve build error"
git push origin main
```

---

## Audit Logging Requirements (Added 2025-01-23)

### âš ï¸ ALWAYS Add Audit Logging to New Features

**When implementing new features, ALWAYS add audit logging:**
- Authentication endpoints â†’ Use appropriate AuditAction
- AI features â†’ Log usage with sanitized metadata
- CRUD operations â†’ Log create/update/delete actions
- Data exports â†’ Log export actions
- Critical user actions â†’ Log for security/compliance

### Audit Helper Function

**Use the helper for all endpoints:**
```typescript
import { getUserContextFromRequest } from '@/lib/audit-context'
import { logAudit } from '@/lib/audit'
import { AuditAction } from '@prisma/client'

export async function POST(request: NextRequest) {
  // Get user context (userId, phone, ip, userAgent)
  const context = await getUserContextFromRequest(request)
  
  // Log the action AFTER validation, BEFORE execution
  await logAudit({
    action: AuditAction.YOUR_ACTION,
    userId: context.userId,
    phone: context.phone,
    ip: context.ip,
    userAgent: context.userAgent,
    metadata: {
      // Add relevant context (NO sensitive data!)
      itemCount: items.length,
      actionType: 'create'
    }
  })
  
  // Continue with endpoint logic...
}
```

### Available Audit Actions

**Authentication:**
- `OTP_SENT`, `OTP_VERIFY_SUCCESS`, `OTP_VERIFY_FAIL`
- `LOGIN_SUCCESS`, `LOGOUT`, `SESSION_REFRESH`
- `DEVICE_TRUST_CREATED`, `DEVICE_TRUST_REVOKED`

**User Management:**
- `USER_CREATED`, `USER_DELETED`, `ROLE_UPDATED`

**Production Orders:**
- `ORDER_CREATED`, `ORDER_VIEWED`, `ORDER_UPDATED`, `ORDER_DELETED`, `ORDER_EXPORTED`

**Recipes:**
- `RECIPE_CREATED`, `RECIPE_VIEWED`, `RECIPE_UPDATED`, `RECIPE_DELETED`, `RECIPE_EXPORTED`

**Work Logs:**
- `WORKLOG_CREATED`, `WORKLOG_UPDATED`, `WORKLOG_DELETED`

**Marketing:**
- `MARKETING_GENERATED`, `MARKETING_EXPORTED`

**AI Features:**
- `AI_GRANULATION_ANALYZED` - Granulation analysis
- `AI_RECIPE_GENERATED` - Recipe generation
- `AI_CHAT_INTERACTION` - Chat/assistant interactions
- `AI_IMAGE_GENERATED` - Image generation

### Metadata Guidelines

**âœ… SAFE to log in metadata:**
- Item counts, IDs
- Feature names, action types
- Non-sensitive request parameters
- Performance metrics

**âŒ NEVER log in metadata:**
- Passwords, OTP codes, tokens
- Full phone numbers (use userId instead)
- Personal identifiable information (PII)
- Full message content (use length or topic only)
- API keys or secrets

**Example - AI Chat:**
```typescript
// âœ… GOOD - Sanitized metadata
metadata: {
  orderCount: orders.length,
  contextPage: 'order-detail',
  messageLength: message.length  // Not full message
}

// âŒ BAD - Exposes content
metadata: {
  fullMessage: message,  // Too much info
  userQuery: sanitizedQuery  // Still contains PII
}
```

### When to Log

**Log AFTER validation, BEFORE main action:**
```typescript
// 1. Parse request
const { data } = await request.json()

// 2. Validate data
if (!isValid(data)) {
  return NextResponse.json({ error: '...' }, { status: 400 })
}

// 3. Get audit context
const context = await getUserContextFromRequest(request)

// 4. LOG HERE (after validation, before execution)
await logAudit({ ... })

// 5. Execute main action
const result = await performAction(data)
```

### Adding New Audit Actions

If you need a new audit action type:

1. Add to Prisma schema (`prisma/schema.prisma`)
2. Run migration: `npx prisma migrate dev --name add_new_audit_actions`
3. Use in code with `AuditAction.NEW_FEATURE_USED`
4. Update audit log viewer with Chinese translation

---

## Best Practices Summary

### DO âœ…
- Always run `npm run build` before git operations
- Write descriptive commit messages
- Fix type errors immediately
- Use design system components
- Test on multiple screen sizes
- Check accessibility

### DON'T âŒ
- Don't skip build testing
- Don't commit broken code
- Don't use `any` type
- Don't hardcode styles
- Don't commit secrets
- Don't push force to main
- Don't commit WIP code

---

**Remember**: A local build test takes 30 seconds. Debugging a broken deployment takes 30 minutes. Always test before pushing! ğŸš€
